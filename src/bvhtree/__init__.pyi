import numpy as np
from typing import List


class QueryResult:
    # Constructors
    def __init__(self) -> None: ...

    # Getters (property)
    @property
    def point(self) -> np.ndarray: ...
    @property
    def distance(self) -> float: ...
    @property
    def face_id(self) -> int: ...


class Triangle:
    # Member variables
    v0: np.ndarray
    v1: np.ndarray
    v2: np.ndarray
    # Constructors
    def __init__(self) -> None: ...
    def __init__(self, v0: np.ndarray, v1: np.ndarray, v2: np.ndarray) -> None: ...
    def __init__(self, vertices: List[np.ndarray]) -> None: ...
    # Member functions
    def compute_normal(self) -> np.ndarray: ...
    def compute_center(self) -> np.ndarray: ...
    def compute_area(self) -> float: ...


class TriangleMesh_core:
    # Constructors
    def __init__(self, vertices: List[np.ndarray], faces: List[np.ndarray]) -> None: ...

    # Getter (read-write property)
    vertices: List[np.ndarray]

    # Getters (Property)
    @property
    def faces(self) -> List[np.ndarray]: ...
    @property
    def num_vertices(self) -> int: ...
    @property
    def num_faces(self) -> int: ...

    # Special getters
    def get_vertex(self, id: int) -> np.ndarray: ...
    def get_face(self, id: int) -> np.ndarray: ...
    def get_triangle(self, id: int) -> Triangle: ...

    # Member functions
    def compute_normals(self) -> List[np.ndarray]: ...
    def compute_centers(self) -> List[np.ndarray]: ...
    def compute_areas(self) -> List[float]: ...

    # In-place transformations
    def translate(self, trans_vec: np.ndarray) -> None: ...
    def scale(self, scale_vec: np.ndarray) -> None: ...
    def rotate(self, angles: np.ndarray) -> None: ...
    def transform(self, trans_mat: np.ndarray) -> None: ...

    # Queries
    def query_closest_point(self, point: np.ndarray) -> QueryResult: ...
    def query_closest_points(self, points: List[np.ndarray], workers: int = 1) -> List[QueryResult]: ...


class AABB:
    # Constructors
    def __init__(self) -> None: ...
    def __init__(self, points: List[np.ndarray]) -> None: ...

    # Getters (property)
    @property
    def min(self) -> np.ndarray: ...
    @property
    def max(self) -> np.ndarray: ...
    @property
    def size(self) -> np.ndarray: ...
    @property
    def center(self) -> np.ndarray: ...
    @property
    def diagonal(self) -> float: ...
    @property
    def largest_axis(self) -> int: ...

    # Member functions
    def reset(self) -> None: ...
    def grow(self, point: np.ndarray) -> None: ...
    def merge(self, other: "AABB") -> None: ...
    def expand(self, delta: float) -> None: ...


class AABBNode:
    # Constructors
    def __init__(self) -> None: ...

    # Getters (property)
    @property
    def aabb(self) -> AABB: ...
    @property
    def parent_id(self) -> int: ...
    @property
    def depth(self) -> int: ...
    @property
    def face_index(self) -> int: ...
    @property
    def face_count(self) -> int: ...

    # Special getters
    def left_child_id(self) -> int: ...
    def right_child_id(self) -> int: ...
    def is_leaf(self) -> bool: ...
    def is_root(self) -> bool: ...


class AABBTree_core:
    # Constructors
    def __init__(self, mesh: TriangleMesh_core, depth_lim: int, split_lim: int) -> None: ...

    # Getters (property)
    @property
    def max_depth(self) -> int: ...
    @property
    def mesh(self) -> TriangleMesh_core: ...
    @property
    def face_ids(self) -> List[int]: ...
    @property
    def nodes(self) -> List[AABBNode]: ...

    # Special getters
    def get_leaf_nodes(self) -> List[AABBNode]: ...
    def get_nodes_at_depth(self, depth: int) -> List[AABBNode]: ...

    # Queries
    def query_closest_point(self, point: np.ndarray) -> QueryResult: ...
    def query_closest_points(self, points: List[np.ndarray], workers: int = 1) -> List[QueryResult]: ...


def closest_point_on_line(point: np.ndarray, a: np.ndarray, b: np.ndarray) -> np.ndarray: ...
def closest_point_on_triangle(point: np.ndarray, a: np.ndarray, b: np.ndarray, c: np.ndarray) -> np.ndarray: ...
def closest_point_on_box(point: np.ndarray, box_min: np.ndarray, box_max: np.ndarray) -> np.ndarray: ...

def box_sphere_intersection(box_min: np.ndarray, box_max: np.ndarray, sphere_center: np.ndarray, sphere_radius: float) -> bool: ...
def box_triangle_intersection(box_min: np.ndarray, box_max: np.ndarray, a: np.ndarray, b: np.ndarray, c: np.ndarray) -> bool: ...